{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/interopRequireDefault\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/classCallCheck\"","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/createClass\"","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/inherits\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/getPrototypeOf\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/assign\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/map\"","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/node/NodeLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/./src/node/NodeStatementUtils.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/toConsumableArray\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/slicedToArray\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/set\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/keys\"","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/utils/NumberUtils.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/get\"","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/get-iterator\"","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/external \"escodegen-wallaby\"","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/freeze\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AbstractPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/external \"espree\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/typeof\"","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/source-code/SourceCode.ts","webpack://JavaScriptObfuscator/./src/source-code/ObfuscatedCode.ts","webpack://JavaScriptObfuscator/external \"events\"","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/./src/EspreeFacade.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/storages/ArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/InputFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ImportDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/array/from\"","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/has-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/define-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-own-property-names\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/get-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-own-property-descriptor\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/define-property\"","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/construct\"","webpack://JavaScriptObfuscator/./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ServiceIdentifiers","NodeType_1","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","ContinueStatement","ExportNamedDeclaration","ExpressionStatement","isFunctionDeclarationNode","isFunctionExpressionNode","isArrowFunctionExpressionNode","FunctionDeclaration","FunctionExpression","Identifier","ImportDeclaration","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isFunctionNode","isBlockStatementNode","nodesWithLexicalStatements","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isIdentifierNode","parentNodeIsPropertyNode","isPropertyNode","computed","parentNodeIsMemberExpressionNode","isMemberExpressionNode","parentNodeIsMethodDefinitionNode","isMethodDefinitionNode","isLabelIdentifierNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","directive","VariableDeclaration","VariableDeclarator","WhileStatement","defaultDescriptor","configurable","initializedTargetMetadataKey","initializablePropertiesSetMetadataKey","wrappedMethodsSetMetadataKey","constructorMethodName","initializeTargetMetadata","metadataKey","metadataValue","target","_hasMetadata","default","_defineMetadata","initializable","initializeMethodName","arguments","length","decoratorName","_keys","this","propertyKey","initializeMethod","Error","concat","_set","ownPropertyNames","_getOwnPropertyNames","prohibitedPropertyNames","forEach","propertyName","initializablePropertiesSet","_getMetadata","wrappedMethodsSet","isProhibitedPropertyName","has","targetProperty","methodDescriptor","_getOwnPropertyDescriptor","originalMethod","_defineProperty","_assign","apply","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","toString","propertyDescriptor","set","newVal","wrapInitializableProperty","escodegen","tslib_1","__importStar","espree","estraverse","NodeGuards_1","NodeMetadata_1","NodeUtils","literalNode","content","raw","precedence","Precedence","Primary","astTree","parentizeAst","cloneRecursive","code","structure","parse","sourceType","replace","enter","parentizeNode","isLiteralNode","addXVerbatimPropertyTo","NodeMetadata","ignoredNode","body","reduce","generate","sourceMapWithCode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","clonedValue","RegExp","Array","isArray","map","_typeof2","TransformationStage","inversify_1","ServiceIdentifiers_1","AbstractNodeTransformer","randomGenerator","options","_classCallCheck2","__decorate","injectable","__param","inject","IRandomGenerator","IOptions","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","AssignmentExpression","BinaryExpression","callee","args","expression","functionName","params","id","identifierNode","generator","test","consequent","alternate","IfStatement","x-verbatim-property","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","GlobalVariableTemplate1_1","GlobalVariableTemplate2_1","AbstractCustomNode","AbstractCustomNode_1","identifierNamesGeneratorFactory","cachedNode","identifierNamesGenerator","_createClass2","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","Factory__IIdentifierNamesGenerator","IdentifierObfuscatingReplacer","ControlFlowCustomNode","AnalyzersModule_1","ControlFlowTransformersModule_1","ConvertingTransformersModule_1","CustomNodesModule_1","FinalizingTransformersModule_1","GeneratorsModule_1","NodeTransformersModule_1","ObfuscatingTransformersModule_1","OptionsModule_1","PreparingTransformersModule_1","StoragesModule_1","UtilsModule_1","JavaScriptObfuscator_1","Logger_1","ObfuscationEventEmitter_1","ObfuscatedCode_1","SourceCode_1","TransformersRunner_1","InversifyContainerFacade","container","Container","serviceIdentifier","named","getNamed","sourceCode","sourceMap","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscatedCode","ObfuscatedCode","Factory__IObfuscatedCode","toFactory","context","obfuscatedCodeAsString","sourceMapAsString","obfuscatedCode","initialize","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","bindingName","cache","_map","_len","dependencies","_key","cachedDependencies","dependency","index","_construct2","constructor","ObfuscationTarget","NodeLexicalScopeUtils","getLexicalScopesRecursive","maxSize","Infinity","nodesWithLexicalScope","depth","ReferenceError","isNodeWithLexicalScope","push","ObfuscationEvent","NodeAppender","nodeWithStatements","statements","parentizeScopeStatementsBeforeAppend","setScopeStatements","_toConsumableArray2","getScopeStatements","stackTraceData","bodyStatements","targetBlockScope","getOptimalBlockScope","prepend","deep","firstCall","stackTrace","indexInScopeStatement","indexOf","insertAtIndex","slice","statement","NodeStatementUtils","getParentNodesWithStatementsRecursive","getSiblingStatementByOffset","isNodeWithStatements","getRootStatementOfNode","getScopeOfNode","nodesWithStatements","isNodeWithLexicalScopeStatements","offset","scopeNode","scopeBody","CustomNode","NodeTransformer","Utils","url","split","hexadecimalPrefix","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","stackTraceLength","getRandomInteger","Math","max","round","InversifyContainerFacade_1","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","obfuscate","unload","version","StringArrayEncoding","SourceMapMode","IdentifierNamesGenerator","AbstractObfuscatingReplacer","NumberUtils","dec","number","IdentifierNamesGenerator_1","ObfuscationTarget_1","SourceMapMode_1","NO_ADDITIONAL_NODES_PRESET","_freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","HexadecimalIdentifierNamesGenerator","identifiersPrefix","inputFileName","log","renameGlobals","reservedNames","rotateStringArray","seed","selfDefending","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","Separate","stringArray","stringArrayEncoding","stringArrayThreshold","Browser","transformObjectKeys","unicodeEscapeSequence","GlobalVariableNoEvalTemplate","AbstractControlFlowReplacer","AbstractControlFlowReplacer_1","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","controlFlowStorage","replacerId","usingExistingIdentifierChance","_this","controlFlowStorageId","getStorageId","storageKeysById","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","storageKey","generateStorageKey","getRandomString","getStorage","identifierDataByControlFlowStorageId","Factory__IControlFlowCustomNode","AbstractCalleeDataExtractor","DEFAULT_PRESET","config","md5_1","__importDefault","chance_1","Initializable_1","RandomGenerator","RandomGenerator_1","min","md5Hash","floor","random","Chance","getSourceCode","Number","integer","pool","randomGeneratorPool","string","postConstruct","MapStorage","storage","storageId","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_getIterator2","next","done","_step$value","_slicedToArray2","err","return","size","mergeId","ObfuscatingGuard","LiteralObfuscatingReplacer","AbstractIdentifierNamesGenerator","some","reservedName","exec","CustomNodeGroup","NodeAppender_1","NodeFactory_1","NodeStatementUtils_1","AbstractPropertiesExtractor","AbstractPropertiesExtractor_1","cachedHostNodesWithStatementsMap","cachedHostStatementsMap","memberExpressionHostNode","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isProhibitedPattern","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","memberExpressionNode","expressionStatementNode","assignmentExpressionNode","isObjectExpressionNode","transformObjectExpressionNode","objectExpressionNode","filter","_this$extractProperti","extractPropertiesToExpressionStatements","_this$extractProperti2","hostStatement","getHostStatement","hostNodeWithStatements","getHostNodeWithStatements","filterExtractedObjectExpressionProperties","insertAfter","propertyNode","propertyKeyNode","isObjectPatternNode","isArrayPatternNode","isAssignmentPatternNode","isRestElementNode","PropertiesExtractor","DeadCodeInjectionCustomNode","ControlFlowCustomNode_1","ExpressionWithOperatorControlFlowReplacer","_AbstractControlFlowR","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","ControlFlowReplacer","CalleeDataExtractor","LoggingPrefix","chalk_1","LoggingPrefix_1","loggingMessage","colorInfo","Base","colorSuccess","colorWarn","loggingLevelColor","loggingPrefix","processedMessage","console","cyan","green","yellow","VisitorDirection","VisitorDirection_1","nodeTransformerFactory","nodeTransformers","transformationStage","visitor","enterVisitors","leaveVisitors","nodeTransformersLength","getVisitor","leave","mergeVisitorsForDirection","Enter","Leave","visitors","direction","visitorsLength","isIgnoredNode","VisitorOption","Skip","visitorFunction","visitorResult","isNode","Factory__INodeTransformer","cryptUtils","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","Inline","btoa","ICryptUtils","events_1","decorate","EventEmitter","_events_1$EventEmitte","EspreeFacade","input","sourceTypeLength","sourceTypes","parseType","error","processParsingError","message","line","lineNumber","column","inputConfig","errorMessage","position","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","formattedPointer","colorError","formattedCodeSlice","substring","red","LoggingMessage","LoggingMessage_1","NodeTransformer_1","TransformationStage_1","EspreeFacade_1","transformersRunner","obfuscatedCodeFactory","logger","timeStart","Date","now","info","Version","ObfuscationStarted","RandomGeneratorSeed","getSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","getObfuscatedCode","espreeParseOptions","runTransformationStage","Preparing","DeadCodeInjection","ControlFlowFlattening","Converting","Obfuscating","Finalizing","warn","EmptySourceCode","escodegenParams","sourceContent","format","transform","transformersList","attachComment","comment","ecmaFeatures","experimentalObjectRestSpread","ecmaVersion","loc","range","verbatim","BlockStatementControlFlowTransformer","ClassDeclarationTransformer","CommentsTransformer","CustomNodesTransformer","DeadCodeInjectionTransformer","EvalCallExpressionTransformer","FunctionControlFlowTransformer","CatchClauseTransformer","FunctionDeclarationTransformer","FunctionTransformer","ImportDeclarationTransformer","LabeledStatementTransformer","LiteralTransformer","MemberExpressionTransformer","MetadataTransformer","MethodDefinitionTransformer","ObfuscatingGuardsTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","ParentificationTransformer","TemplateLiteralTransformer","VariableDeclarationTransformer","EscapeSequenceEncoder","stringsCache","encodeAllSymbols","cacheKey","String","template","replaceRegExp","escapeSequenceRegExp","regExp","character","charCodeAt","Utils_1","CryptUtils","output","encodeURIComponent","match","p1","fromCharCode","parseInt","block","charCode","idx","charAt","str","randomStringDiff","randomStringDiffArray","shuffle","s1","s2","i1","i2","randomMerge","join","x","j","y","ArrayUtils","array","times","temp","newArray","pop","unshift","shuffledArray","_ref","ArrayUtils_1","CryptUtils_1","EscapeSequenceEncoder_1","ContainerModule","IArrayUtils","IEscapeSequenceEncoder","ArrayStorage","storageLength","splice","ArrayStorage_1","StringArrayStorage","StringArrayStorage_1","_ArrayStorage_1$Array","arrayUtils","_get2","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","stringArrayName","stringArrayCallsWrapperName","rotationValue","rotate","CustomNodeGroup_1","MapStorage_1","CustomNodeGroupStorage","CustomNodeGroupStorage_1","_MapStorage_1$MapStor","customNodeGroupFactory","_this2","customNodeGroupsList","customNodeGroupName","customNodeGroup","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNodeGroup","ControlFlowStorage","ControlFlowStorage_1","TCustomNodeGroupStorage","TStringArrayStorage","Newable__TControlFlowStorage","toConstructor","Factory__TControlFlowStorage","AbstractNodeTransformer_1","NodeUtils_1","_AbstractNodeTransfor","transformNode","ObfuscatingGuard_1","ObfuscatingGuardsTransformer_1","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","obfuscationAllowed","every","nodeGuard","check","BlackListNodeGuard","ConditionalCommentNodeGuard","Factory__INodeGuard","renamedIdentifier","replacedLiteral","js_string_escape_1","EvalCallExpressionTransformer_1","evalRootAstHostNodeSet","isCallExpressionNode","isEvalRootAstHostNode","restoreNode","callExpressionNode","callExpressionFirstArgument","ast","evalString","extractEvalStringFromCallExpressionArgument","convertCodeToStructure","_a","evalRootAstHostNode","functionExpressionNode","blockStatementNode","targetAst","convertStructureToCode","extractEvalStringFromLiteralNode","isTemplateLiteralNode","extractEvalStringFromTemplateLiteralNode","quasis","expressions","cooked","ObfuscationEvent_1","stackTraceAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","analyzeNode","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","analyze","_this3","once","getAppendEvent","appendCustomNodes","emit","BeforeObfuscation","AfterObfuscation","IStackTraceAnalyzer","ConditionalCommentObfuscatingGuard","ConditionalCommentObfuscatingGuard_1","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","isNodeWithComments","checkComments","comments","commentsLength","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","CommentsTransformer_1","transformComments","preservedWords","preservedWord","BlackListObfuscatingGuard","BlackListObfuscatingGuard_1","blackListGuardsLength","blackListGuards","isUseStrictOperator","CustomNodesTransformer_1","EvaCallExpressionTransformer_1","MetadataTransformer_1","ParentificationTransformer_1","INodeTransformer","whenTargetNamed","INodeGuard","getCacheFactory","StringArrayThresholdRule","StringArrayEncoding_1","StringArrayEncodingRule","Base64","StringArrayRule","SourceMapFileNameRule","SourceMapBaseUrlRule","endsWith","SelfDefendingRule","InputFileNameRule","DomainLockRule","normalizedDomains","domain","extractDomainFrom","DeadCodeInjectionThresholdRule","Default_1","DeadCodeInjectionRule","ControlFlowFlatteningThresholdRule","ControlFlowFlatteningThresholdRule_1","DeadCodeInjectionRule_1","DeadCodeInjectionThresholdRule_1","DomainLockRule_1","InputFileNameRule_1","SelfDefendingRule_1","SourceMapBaseUrlRule_1","SourceMapFileNameRule_1","StringArrayRule_1","StringArrayEncodingRule_1","StringArrayThresholdRule_1","OptionsNormalizer","OptionsNormalizer_1","normalizedOptions","normalizerRules","normalizerRule","ValidationErrorsFormatter","errors","errorMessages","formatWithNestedConstraints","constraints","rootError","nestedErrors","constraint","class_validator_1","ValidationErrorsFormatter_1","Options","Options_1","optionsNormalizer","validateSync","validatorOptions","normalize","validationError","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","MangledIdentifierNamesGenerator","ValidateIf","IsUrl","require_protocol","require_tld","require_valid_protocol","Rc4","BrowserNoEval","Node","IOptionsNormalizer","IdentifierObfuscatingReplacer_1","NodeLexicalScopeUtils_1","identifierObfuscatingReplacerFactory","replaceableIdentifiers","identifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","isVariableDeclarationNode","isExportNamedDeclarationNode","variableDeclarationNode","lexicalScopeNode","getLexicalScope","isGlobalDeclaration","storeVariableNames","replaceScopeCachedIdentifiers","replaceScopeIdentifiers","traverseDeclarationIdentifiers","storeGlobalName","storeLocalName","_this4","cachedReplaceableIdentifiersNamesMap","identifierNames","identifierName","cachedReplaceableIdentifiers","cachedReplaceableIdentifierLength","replaceableIdentifier","newReplaceableIdentifier","_this5","storedReplaceableIdentifiersNamesMap","isReplaceableIdentifierNode","isRenamedIdentifier","newIdentifierName","storedReplaceableIdentifiers","declarationNode","traverse","Factory__IIdentifierObfuscatingReplacer","AbstractObfuscatingReplacer_1","NumberUtils_1","StringLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer_1","_AbstractObfuscatingR","stringArrayStorage","escapeSequenceEncoder","nodesCache","stringLiteralHexadecimalIndexCache","rc4Keys","rc4KeyLength","rc4KeysCount","nodeValue","useStringArray","canUseStringArray","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","minimumLengthForStringArray","stringArrayStorageLength","fromCache","hexadecimalRawIndex","toHex","hexadecimalIndex","encodedValue","rc4","encode","_this$getEncodedValue","getEncodedValue","escapedValue","getLength","stringArrayStorageCallsWrapperName","_this$getStringArrayH","getStringArrayHexadecimalIndex","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","hexadecimalLiteralNode","literalValue","rc4KeyLiteralNode","NumberLiteralObfuscatingReplacer","numberLiteralCache","rawValue","isCeil","LiteralObfuscatingReplacer_1","literalObfuscatingReplacerFactory","isReplacedLiteral","isProhibitedNode","BooleanLiteralObfuscatingReplacer","isImportDeclarationNode","Factory__IObfuscatingReplacer","labeledStatementNode","storeLabeledStatementName","replaceLabeledStatementName","newIdentifier","ImportDeclarationTransformer_1","importDeclarationNode","storeImportSpecifierNames","specifiers","importSpecifierNode","isProhibitedImportSpecifierNode","local","isImportSpecifierNode","imported","FunctionTransformer_1","functionNode","storeFunctionParams","replaceFunctionParams","paramsNode","isProhibitedPropertyNode","ignoredIdentifierNamesSet","replaceVisitor","functionDeclarationNode","storeFunctionName","isClassDeclarationNode","classDeclarationNode","storeClassName","isCatchClauseNode","catchClauseNode","storeCatchClauseParam","replaceCatchClauseParam","param","BooleanLiteralObfuscatingReplacer_1","getTrueUnaryExpressionNode","getFalseUnaryExpressionNode","arrayExpressionNode","blockScopesMap","namesMap","nodeName","isReservedName","generateWithPrefix","BaseIdentifierObfuscatingReplacer_1","CatchClauseTransformer_1","ClassDeclarationTransformer_1","FunctionDeclarationTransformer_1","LabeledStatementTransformer_1","LiteralTransformer_1","NumberLiteralObfuscatingReplacer_1","VariableDeclarationTransformer_1","IObfuscatingReplacer","IIdentifierObfuscatingReplacer","AbstractIdentifierNamesGenerator_1","MangledIdentifierNamesGenerator_1","_AbstractIdentifierNa","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","nameSequence","nameLength","zeroSequence","num","repeat","indexInSequence","newMangledName","isValidIdentifierName","HexadecimalIdentifierNamesGenerator_1","randomVariableNameSet","randomInteger","baseIdentifierName","substr","baseIdentifierNameLength","IIdentifierNamesGenerator","cachedIdentifierNamesGenerator","StringLiteralNode","_AbstractCustomNode_","StringLiteralControlFlowStorageCallNode","controlFlowStorageName","controlFlowStorageKey","StringArrayRotateFunctionTemplate","SelfDefendingTemplate","string_template_1","NoCustomNodes_1","SelfDefendingTemplate_1","StringArrayRotateFunctionTemplate_1","JavaScriptObfuscatorFacade_1","StringArrayRotateFunctionNode","stringArrayRotateValue","getTemplate","timesName","whileFunctionName","StringArrayTemplate","StringArrayTemplate_1","StringArrayNode","rotateArray","StringArrayRc4DecodeNodeTemplate","initializedIdentifier","rc4Identifier","dataIdentifier","onceIdentifier","StringArrayCallsWrapperTemplate","StringArrayBase64DecodeNodeTemplate","base64DecodeFunctionIdentifier","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","Rc4Template","AtobTemplate","AtobTemplate_1","GlobalVariableNoEvalTemplate_1","Rc4Template_1","StringArrayBase64DecodeNodeTemplate_1","StringArrayCallsWrapperTemplate_1","StringArrayRC4DecodeNodeTemplate_1","StringArrayCallsWrapper","decodeNodeTemplate","getDecodeStringArrayTemplate","globalVariableTemplate","getGlobalVariableTemplate","atobPolyfill","decodeStringArrayTemplate","selfDefendingCode","rc4Polyfill","SelfDefendingUnicodeNode","callsControllerFunctionName","selfDefendingFunctionName","singleNodeCallControllerFunctionName","SingleNodeCallControllerTemplate","SingleNodeCallControllerTemplate_1","NodeCallsControllerFunctionNode","LogicalExpressionFunctionNode","returnStatementNode","logicalExpressionNode","leftValue","rightValue","DomainLockNodeTemplate","DomainLockNodeTemplate_1","DomainLockNode","domainsString","_this$cryptUtils$hide","hideString","_this$cryptUtils$hide2","hiddenDomainsString","diff","domainLockFunctionName","domains","DebugProtectionFunctionTemplate","DebuggerTemplateNoEval","DebuggerTemplate","DebuggerTemplate_1","DebuggerTemplateNoEval_1","DebugProtectionFunctionTemplate_1","DebugProtectionFunctionNode","debugProtectionFunctionName","debuggerTemplate","DebugProtectionFunctionIntervalTemplate","DebugProtectionFunctionIntervalTemplate_1","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionCallTemplate_1","DebugProtectionFunctionCallNode","ConsoleOutputDisableExpressionTemplate","ConsoleOutputDisableExpressionTemplate_1","ConsoleOutputDisableExpressionNode","consoleLogDisableFunctionName","ControlFlowStorageNode","propertyNodes","_from","_ref2","variableDeclaratorNode","CallExpressionFunctionNode","expressionArguments","calleeIdentifier","argumentsLength","CallExpressionControlFlowStorageCallNode","BlockStatementDeadCodeInjectionNode","deadCodeInjectionRootAstHostNode","random1","random2","leftString","rightString","ifStatementNode","binaryExpressionNode","BlockStatementControlFlowFlatteningNode","blockStatementBody","shuffledKeys","originalKeysIndexesInShuffledArray","controllerIdentifierName","indexIdentifierName","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","BinaryExpressionFunctionNode","CustomNode_1","AbstractCustomNodeGroup_1","_AbstractCustomNodeGr","customNodeFactory","appendCustomNodeIfExist","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","_stringArrayStorageId","_stringArrayStorageId2","Factory__ICustomNode","randomStackTraceIndex","getRandomStackTraceIndex","appendToOptimalBlockScope","targetNodeWithStatements","selfDefendingUnicodeNode","nodeCallsControllerFunctionNode","domainLockNode","append","programBodyLength","randomIndex","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","consoleOutputDisableExpressionNode","DeadCodeInjectionCustomNode_1","ConsoleOutputCustomNodeGroup_1","DebugProtectionCustomNodeGroup_1","DomainLockCustomNodeGroup_1","SelfDefendingCustomNodeGroup_1","StringArrayCustomNodeGroup_1","BinaryExpressionFunctionNode_1","BlockStatementControlFlowFlatteningNode_1","BlockStatementDeadCodeInjectionNode_1","CallExpressionControlFlowStorageCallNode_1","CallExpressionFunctionNode_1","ControlFlowStorageNode_1","ConsoleOutputDisableExpressionNode_1","DebugProtectionFunctionCallNode_1","DebugProtectionFunctionIntervalNode_1","DebugProtectionFunctionNode_1","DomainLockNode_1","ExpressionWithOperatorControlFlowStorageCallNode_1","LogicalExpressionFunctionNode_1","NodeCallsControllerFunctionNode_1","SelfDefendingUnicodeNode_1","StringArrayCallsWrapper_1","StringArrayNode_1","StringArrayRotateFunctionNode_1","StringLiteralControlFlowStorageCallNode_1","StringLiteralNode_1","ICustomNode","Newable__ICustomNode","ICustomNodeGroup","getFactory","getConstructorFactory","Factory__IDeadCodeInjectionCustomNode","VariableDeclaratorPropertiesExtractor","_AbstractPropertiesEx","hostNode","isProhibitedObjectExpressionNode","isVariableDeclaratorNode","hostVariableDeclarator","getHostVariableDeclaratorNode","getHostVariableDeclarationNode","indexOfDeclarator","variableDeclarator","Break","TemplateLiteralTransformer_1","isValidTemplateLiteralNode","templateLiteralNode","transformedNode","templateLiteralExpressions","nodes","templateElement","shift","isLiteralNodeWithStringValue","root","isTaggedTemplateExpressionNode","transformComputedProperty","transformBaseProperty","getPropertyKeyValue","inputValue","PropertiesExtractor_1","ObjectExpressionKeysTransformer_1","propertiesExtractorFactory","propertiesExtractorName","propertiesExtractorsMap","extract","AssignmentExpressionPropertiesExtractor","Factory__IPropertiesExtractor","MethodDefinitionTransformer_1","methodDefinitionNode","ignoredNames","leftNode","AssignmentExpressionPropertiesExtractor_1","MemberExpressionTransformer_1","ObjectExpressionTransformer_1","VariableDeclaratorPropertiesExtractor_1","IPropertiesExtractor","StringLiteralControlFlowReplacer","StringLiteralControlFlowReplacer_1","literalFunctionCustomNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","ExpressionWithOperatorControlFlowReplacer_1","LogicalExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer_1","_ExpressionWithOperat","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","expressionNode","nodeForCheck","ControlFlowReplacer_1","FunctionControlFlowTransformer_1","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","getHostNode","getControlFlowStorage","transformFunctionBody","controlFlowStorageCustomNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","getParentNodesWithStatements","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","Factory__IControlFlowReplacer","DeadCodeInjectionTransformer_1","deadCodeInjectionCustomNodeFactory","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","isDeadCodeInjectionRootAstHostNode","programNode","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","transformedBlockStatementNode","makeClonedBlockStatementNodeUnique","minCollectedBlockStatementsCount","isValidWrappedBlockStatementNode","maxInteger","randomBlockStatementNode","replaceBlockStatementNode","hostNodeFirstStatement","transformersToRenameBlockScopeIdentifiers","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","newBlockStatementNode","targetNode","isAwaitExpressionNode","isSuperNode","indexInScope","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","getParentNodeWithStatements","CallExpressionControlFlowReplacer_1","callExpressionFunctionCustomNode","BlockStatementControlFlowTransformer_1","canTransformBlockStatementNode","originalKeys","createWithRange","blockStatementControlFlowFlatteningCustomNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isClassDeclaration","canTransform","isWhileStatementNode","isProhibitedStatementNode","BinaryExpressionControlFlowReplacer_1","binaryExpressionFunctionCustomNode","IControlFlowReplacer","CalleeDataExtractor_1","StackTraceAnalyzer","StackTraceAnalyzer_1","calleeDataExtractorFactory","analyzeRecursive","blockScopeBody","limitIndex","getLimitIndex","blockScopeBodyLength","_loop","blockScopeBodyNode","analyzeCallExpressionNode","calleeDataExtractorsList","calleeDataExtractorName","calleeData","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitThreshold","FunctionDeclarationCalleeDataExtractor","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","AbstractCalleeDataExtractor_1","ObjectExpressionCalleeDataExtractor_1","_AbstractCalleeDataEx","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","calleeBlockStatement","getCalleeBlockStatement","currentChain","memberExpression","objectName","findCalleeBlockStatement","objectExpressionProperties","nextItemInCallsChain","isValidTargetPropertyNode","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","FunctionDeclarationCalleeDataExtractor_1","FunctionExpressionCalleeDataExtractor_1","ICalleeDataExtractor"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 227);\n","module.exports = require(\"@babel/runtime/helpers/interopRequireDefault\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"inversify\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"tslib\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscatedCode = 'Factory<IObfuscatedCode>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__IPropertiesExtractor = 'Factory<IPropertiesExtractor>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscatedCode = 'IObfuscatedCode',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IPropertiesExtractor = 'IPropertiesExtractor',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IStackTraceAnalyzer = 'IStackTraceAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithLexicalStatements: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (node: ESTree.Node): node is ESTree.ClassDeclaration {\n        return node.type === NodeType.ClassDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionNode (node: ESTree.Node): node is ESTree.Function {\n        return NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isProgramNode(node) || NodeGuards.isFunctionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScopeStatements (\n        node: ESTree.Node,\n        parentNode: ESTree.Node\n    ): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || (NodeGuards.isBlockStatementNode(node) && NodeGuards.nodesWithLexicalStatements.includes(parentNode.type));\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithStatements (node: ESTree.Node): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!NodeGuards.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = NodeGuards.isPropertyNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            NodeGuards.isMemberExpressionNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.property === node\n        );\n        const parentNodeIsMethodDefinitionNode: boolean = NodeGuards.isMethodDefinitionNode(parentNode) &&\n            !parentNode.computed;\n        const isLabelIdentifierNode: boolean = NodeGuards.isLabelIdentifierNode(node, parentNode);\n\n        return !parentNodeIsPropertyNode &&\n            !parentNodeIsMemberExpressionNode &&\n            !parentNodeIsMethodDefinitionNode &&\n            !isLabelIdentifierNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey.toString()}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey.toString()}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","import * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObject } from '../types/TObject';\n\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} literalNode\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyTo (literalNode: ESTree.Literal): ESTree.Literal {\n        literalNode['x-verbatim-property'] = {\n            content: literalNode.raw,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentizeAst(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = espree.parse(code, { sourceType: 'script' });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n\n                if (NodeGuards.isLiteralNode(node)) {\n                    NodeUtils.addXVerbatimPropertyTo(node);\n                }\n\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentizeAst <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: TObject = {};\n\n        Object\n            .keys(node)\n            .forEach((property: string) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[<keyof T>property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = clonedValue;\n            });\n\n        return <T>copy;\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/assign\");","export enum TransformationStage {\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        return {\n            type: NodeType.BreakStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        return {\n            type: NodeType.ContinueStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {unknown[]} args\n     */\n    public abstract initialize (...args: unknown[]): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n","module.exports = require(\"@babel/runtime/core-js/map\");","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} identifierNode\n     * @returns {boolean}\n     */\n    public static isRenamedIdentifier (identifierNode: ESTree.Identifier): boolean {\n        return NodeMetadata.get<ESTree.IdentifierNodeMetadata>(identifierNode, 'renamedIdentifier') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","module.exports = require(\"string-template\");","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscatedCode } from '../source-code/ObfuscatedCode';\nimport { SourceCode } from '../source-code/SourceCode';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, sourceMap: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode, sourceMap))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode)\n            .to(ObfuscatedCode);\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.Factory__IObfuscatedCode)\n            .toFactory<IObfuscatedCode>((context: interfaces.Context) => {\n                return (obfuscatedCodeAsString: string, sourceMapAsString: string) => {\n                    const obfuscatedCode: IObfuscatedCode = context.container\n                        .get<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode);\n\n                    obfuscatedCode.initialize(obfuscatedCodeAsString, sourceMapAsString);\n\n                    return obfuscatedCode;\n                };\n            });\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","export enum ObfuscationTarget {\n    Browser = 'browser',\n    BrowserNoEval = 'browser-no-eval',\n    Node = 'node'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static append (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n            ...statements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} bodyStatements\n     * @param {number} index\n     */\n    public static appendToOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        nodeWithStatements: TNodeWithStatements,\n        bodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        const targetBlockScope: TNodeWithStatements = stackTraceData.length\n            ? NodeAppender.getOptimalBlockScope(stackTraceData, index)\n            : nodeWithStatements;\n\n        NodeAppender.prepend(targetBlockScope, bodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = stackTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertAfter (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {number} index\n     */\n    public static insertAtIndex (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        index: number\n    ): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(0, index),\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static prepend (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @returns {TStatement[]}\n     */\n    private static getScopeStatements (nodeWithStatements: TNodeWithStatements): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            return nodeWithStatements.consequent;\n        }\n\n        return nodeWithStatements.body;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[]\n    ): TStatement[] {\n        statements.forEach((statement: TStatement) => {\n            statement.parentNode = nodeWithStatements;\n        });\n\n        return statements;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    private static setScopeStatements (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            nodeWithStatements.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        nodeWithStatements.body = statements;\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeStatementUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getParentNodeWithStatements (node: ESTree.Node): TNodeWithStatements {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements[]}\n     */\n    public static getParentNodesWithStatements (node: ESTree.Node): TNodeWithStatements[] {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, 1);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, -1);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Statement}\n     */\n    public static getRootStatementOfNode (node: ESTree.Node): ESTree.Statement {\n        if (NodeGuards.isProgramNode(node)) {\n            throw new Error('Unable to find root statement for `Program` node');\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getRootStatementOfNode(parentNode);\n        }\n\n        return <ESTree.Statement>node;\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithStatements {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithStatements[]} nodesWithStatements\n     * @param {number} depth\n     * @returns {TNodeWithStatements[]}\n     */\n    private static getParentNodesWithStatementsRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithStatements: TNodeWithStatements[] = [],\n        depth: number = 0\n    ): TNodeWithStatements[] {\n        if (nodesWithStatements.length >= maxSize) {\n            return nodesWithStatements;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            (NodeGuards.isNodeWithLexicalScopeStatements(node, parentNode) && depth > 0)\n        ) {\n            nodesWithStatements.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeStatementUtils.getParentNodesWithStatementsRecursive(parentNode, maxSize, nodesWithStatements, ++depth);\n        }\n\n        return nodesWithStatements;\n    }\n\n    /**\n     * @param {Statement} statement\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementByOffset (statement: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(statement);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(statement);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","module.exports = require(\"@babel/runtime/core-js/set\");","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    ImportDeclarationTransformer = 'ImportDeclarationTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer'\n}\n","export class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFrom (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public abstract appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} stackTraceLength\n     * @returns {number}\n     */\n    protected getRandomStackTraceIndex (stackTraceLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(stackTraceLength - 1)));\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/keys\");","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @type {string | undefined}\n     */\n    public static version: string = process.env.VERSION || 'unknown';\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscatedCode}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscatedCode {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, '', inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscatedCode: IObfuscatedCode = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscatedCode;\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","export enum StringArrayEncoding {\n    Base64 = 'base64',\n    Rc4 = 'rc4'\n}\n","export enum SourceMapMode {\n    Inline = 'inline',\n    Separate = 'separate'\n}\n","export enum IdentifierNamesGenerator {\n    HexadecimalIdentifierNamesGenerator = 'hexadecimal',\n    MangledIdentifierNamesGenerator = 'mangled'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../../../types/node/TNodeWithLexicalScope';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral[\"value\"]} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], lexicalScopeNode?: TNodeWithLexicalScope): ESTree.Node;\n}\n","export class NumberUtils {\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static toHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeil (number: number): boolean {\n        return number % 1 === 0;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/get\");","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"@babel/runtime/core-js/get-iterator\");","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        var that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","module.exports = require(\"escodegen-wallaby\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"chalk\");","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private seed!: number;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        };\n\n        /**\n         * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n         * for different bundles with same seed\n         *\n         * @returns {number}\n         */\n        const getSeed: () => number = (): number => {\n            const md5Hash: string = md5(this.sourceCode.getSourceCode());\n\n            return this.seed + Number(md5Hash.replace(/\\D/g, ''));\n        };\n\n        this.seed = this.options.seed !== 0 ? this.options.seed : getRandomInteger(0, 999_999_999);\n        this.randomGenerator = new Chance(getSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getSeed (): number {\n        return this.seed;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public get (key: K): V {\n        const value: V | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","export enum ObfuscatingGuard {\n    BlackListNodeGuard = 'BlackListNodeGuard',\n    ConditionalCommentNodeGuard = 'ConditionalCommentNodeGuard'\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public abstract generate (): string;\n\n    /**\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (): string;\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (name: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(name) !== null\n            )\n            : true;\n\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/freeze\");","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport abstract class AbstractPropertiesExtractor implements IPropertiesExtractor {\n    /**\n     * @type {Map<ESTree.ObjectExpression, TNodeWithStatements>}\n     */\n    protected readonly cachedHostNodesWithStatementsMap: Map <ESTree.ObjectExpression, TNodeWithStatements> = new Map();\n\n    /**\n     * @type {Map<ESTree.ObjectExpression, ESTree.Statement>}\n     */\n    protected readonly cachedHostStatementsMap: Map <ESTree.ObjectExpression, ESTree.Statement> = new Map();\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    protected static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        }\n\n        if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedPattern (node: ESTree.Node): node is ESTree.Pattern {\n        return NodeGuards.isObjectPatternNode(node)\n            || NodeGuards.isArrayPatternNode(node)\n            || NodeGuards.isAssignmentPatternNode(node)\n            || NodeGuards.isRestElementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} hostNode\n     * @returns {Node}\n     */\n    public abstract extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.Node\n    ): ESTree.Node;\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionHostNode\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    protected extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionHostNode: ESTree.Expression\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (AbstractPropertiesExtractor.isProhibitedPattern(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = AbstractPropertiesExtractor.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionHostNode, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {number[]} removablePropertyIds\n     */\n    protected filterExtractedObjectExpressionProperties (\n        objectExpressionNode: ESTree.ObjectExpression,\n        removablePropertyIds: number[]\n    ): void {\n        objectExpressionNode.properties = objectExpressionNode.properties\n            .filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionHostNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Expression\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionHostNode);\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertAfter(hostNodeWithStatements, expressionStatements, hostStatement);\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Statement} hostStatement\n     * @returns {TNodeWithStatements}\n     */\n    protected getHostNodeWithStatements (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostStatement: ESTree.Statement\n    ): TNodeWithStatements {\n        if (this.cachedHostNodesWithStatementsMap.has(objectExpressionNode)) {\n            return <TNodeWithStatements>this.cachedHostNodesWithStatementsMap.get(objectExpressionNode);\n        }\n\n        const nodeWithStatements: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(hostStatement);\n\n        this.cachedHostNodesWithStatementsMap.set(objectExpressionNode, nodeWithStatements);\n\n        return nodeWithStatements;\n    }\n\n    /**\n     * Returns host statement of object expression node\n     *\n     * @param {NodeGuards} objectExpressionNode\n     * @returns {Node}\n     */\n    protected getHostStatement (objectExpressionNode: ESTree.ObjectExpression): ESTree.Statement {\n        if (this.cachedHostStatementsMap.has(objectExpressionNode)) {\n            return <ESTree.Statement>this.cachedHostStatementsMap.get(objectExpressionNode);\n        }\n\n        const hostStatement: ESTree.Statement = NodeStatementUtils.getRootStatementOfNode(objectExpressionNode);\n\n        this.cachedHostStatementsMap.set(objectExpressionNode, hostStatement);\n\n        return hostStatement;\n    }\n}\n","export enum PropertiesExtractor {\n    AssignmentExpressionPropertiesExtractor = 'AssignmentExpressionPropertiesExtractor',\n    VariableDeclaratorPropertiesExtractor = 'VariableDeclaratorPropertiesExtractor'\n}\n","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","module.exports = require(\"espree\");","module.exports = require(\"@babel/runtime/helpers/typeof\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","module.exports = require(\"reflect-metadata\");","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformers\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformers: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformers.length) {\n            return astTree;\n        }\n\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor | null;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor(transformationStage);\n\n            if (!visitor) {\n                continue;\n            }\n\n            if (visitor.enter) {\n                enterVisitors.push({ enter: visitor.enter });\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push({ leave: visitor.leave });\n            }\n        }\n\n        if (!enterVisitors.length && !leaveVisitors.length) {\n            return astTree;\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","import { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @type {string}\n     */\n    private readonly sourceMap: string;\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     */\n    constructor (sourceCode: string, sourceMap: string) {\n        this.sourceCode = sourceCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.sourceCode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { IOptions } from '../interfaces/options/IOptions';\n\n@injectable()\nexport class ObfuscatedCode implements IObfuscatedCode {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    constructor (\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.correctObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    private correctObfuscatedCode (): string {\n        if (!this.sourceMap) {\n            return this.obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(this.sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return this.obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${this.obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","module.exports = require(\"events\");","import { decorate, injectable } from 'inversify';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\nimport { EventEmitter } from 'events';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","import * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `espree`\n */\nexport class EspreeFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {SourceType[]}\n     */\n    private static readonly sourceTypes: espree.SourceType[] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: espree.ParseOptions): ESTree.Program | never {\n        const sourceTypeLength: number = EspreeFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return EspreeFacade.parseType(input, config, EspreeFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(EspreeFacade.processParsingError(\n                    input,\n                    error.message,\n                    {\n                        line: error.lineNumber,\n                        column: error.column,\n                    }\n                ));\n            }\n        }\n\n        throw new Error(`Espree parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} inputConfig\n     * @param {SourceType} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: espree.ParseOptions,\n        sourceType: espree.SourceType\n    ): ESTree.Program {\n        const config: espree.ParseOptions = { ...inputConfig, sourceType };\n\n        return espree.parse(input, config);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - EspreeFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + EspreeFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EspreeFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport { TObfuscatedCodeFactory } from './types/container/source-code/TObfuscatedCodeFactory';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EspreeFacade } from './EspreeFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly espreeParseOptions: espree.ParseOptions = {\n        attachComment: true,\n        comment: true,\n        ecmaFeatures: {\n            experimentalObjectRestSpread: true\n        },\n        ecmaVersion: 9,\n        loc: true,\n        range: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.ImportDeclarationTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {TObfuscatedCodeFactory}\n     */\n    private readonly obfuscatedCodeFactory: TObfuscatedCodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {TObfuscatedCodeFactory} obfuscatedCodeFactory\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.Factory__IObfuscatedCode) obfuscatedCodeFactory: TObfuscatedCodeFactory,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.randomGenerator = randomGenerator;\n        this.obfuscatedCodeFactory = obfuscatedCodeFactory;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscatedCode}\n     */\n    public obfuscate (sourceCode: string): IObfuscatedCode {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, process.env.VERSION);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscatedCode(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EspreeFacade.parse(sourceCode, JavaScriptObfuscator.espreeParseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = this.options.inputFileName || 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscatedCode}\n     */\n    private getObfuscatedCode (generatorOutput: IGeneratorOutput): IObfuscatedCode {\n        return this.obfuscatedCodeFactory(generatorOutput.code, generatorOutput.map);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n","module.exports = require(\"chance\");","module.exports = require(\"md5\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * Hides string inside a other random string with larger length\n     *\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            ''\n        );\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public createWithRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public rotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public shuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n});\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayStorage } from '../interfaces/storages/IArrayStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <V> implements IArrayStorage <V> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {V[]}\n     */\n    @initializable()\n    protected storage!: V[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {V}\n     */\n    public get (key: number): V {\n        const value: V | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {number}\n     */\n    public getKeyOf (value: V): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {V[]}\n     */\n    public getStorage (): V[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {V} value\n     */\n    public set (key: number, value: V): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.rotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListNodeGuard,\n        ObfuscatingGuard.ConditionalCommentNodeGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isIdentifierNode(node)) {\n            NodeMetadata.set(node, { renamedIdentifier: false });\n        }\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    private stackTraceData: IStackTraceData[] = [];\n\n    /**\n     * @param {IStackTraceAnalyzer} stackTraceAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.stackTraceData = this.stackTraceAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.stackTraceData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.stackTraceData);\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isNodeWithComments(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     *\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node {\n        if (node.leadingComments) {\n            node.leadingComments = this.transformComments(node.leadingComments);\n        }\n\n        if (node.trailingComments) {\n            node.trailingComments = this.transformComments(node.trailingComments);\n        }\n\n        return node;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord))\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvaCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListNodeGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentNodeGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n});\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .split('.')[0];\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const InputFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { inputFileName } = options;\n\n    if (inputFileName) {\n        inputFileName = inputFileName\n            .replace(/^\\/+/, '')\n            .split('.')\n            .slice(0, -1)\n            .join('.') || inputFileName;\n\n        options = {\n            ...options,\n            inputFileName: `${inputFileName}.js`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFrom(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { InputFileNameRule } from './normalizer-rules/InputFileNameRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        InputFileNameRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { ValidationError } from 'class-validator';\n\nimport { TObject } from '../types/TObject';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} errors\n     * @returns {string}\n     */\n    public static format (errors: ValidationError[]): string {\n        return errors\n            .reduce(\n                (errorMessages: string[], error: ValidationError) => ([\n                    ...errorMessages,\n                    ValidationErrorsFormatter.formatWithNestedConstraints(error)\n                ]),\n                []\n            )\n            .join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} error\n     * @returns {string}\n     */\n    private static formatWithNestedConstraints (error: ValidationError): string {\n        const constraints: TObject<string> = error.constraints;\n\n        const rootError: string = `\\`${error.property}\\` errors:\\n`;\n        const nestedErrors: string = Object\n            .keys(constraints)\n            .map((constraint: string) => `    - ${constraints[constraint]}\\n`)\n            .join();\n\n        return `${rootError}${nestedErrors}`;\n    }\n}\n","module.exports = require(\"class-validator\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: IdentifierNamesGenerator;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly inputFileName!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: SourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: ObfuscationTarget;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isVariableDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(variableDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return variableDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? lexicalScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, lexicalScopeNode, scopeNode);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, lexicalScopeNode);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            if (isGlobalDeclaration) {\n                this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, lexicalScopeNode);\n            } else {\n                this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, lexicalScopeNode);\n            }\n        });\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Node} scopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        scopeNode: ESTree.Node\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(scopeNode);\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined =\n                cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {Node} scopeNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (identifier: ESTree.Identifier) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                estraverse.traverse(declarationNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node);\n                        }\n                    }\n                });\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStringArrayStorage } from '../../../../types/storages/TStringArrayStorage';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = NumberUtils.toHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        NodeMetadata.set(stringArrayIdentifierNode, { renamedIdentifier: true });\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!NumberUtils.isCeil(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(nodeValue, rawValue);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer)\n                    .replace(<boolean>literalNode.value);\n\n            case 'number':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer)\n                    .replace(<number>literalNode.value);\n\n            case 'string':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer)\n                    .replace(<string>literalNode.value);\n\n            default:\n                return literalNode;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(labeledStatementNode);\n\n        if (!lexicalScopeNode) {\n            return labeledStatementNode;\n        }\n\n        this.storeLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n        this.replaceLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, lexicalScopeNode);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TImportSpecifier } from '../../types/node/TimportSpecifier';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     import foo from './foo';\n *     import * as bar from './bar';\n *\n * on:\n *     import _0x12d45f from './foo';\n *     import * as _0x12d45f from './bar';\n */\n@injectable()\nexport class ImportDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TImportSpecifier} importSpecifierNode\n     * @returns {boolean}\n     */\n    private static isProhibitedImportSpecifierNode (importSpecifierNode: TImportSpecifier): boolean {\n        return NodeGuards.isImportSpecifierNode(importSpecifierNode)\n            && importSpecifierNode.imported.name === importSpecifierNode.local.name;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isImportDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (importDeclarationNode: ESTree.ImportDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(importDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return importDeclarationNode;\n        }\n\n        this.storeImportSpecifierNames(importDeclarationNode, lexicalScopeNode);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return importDeclarationNode;\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeImportSpecifierNames (\n        importDeclarationNode: ESTree.ImportDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        importDeclarationNode.specifiers.forEach((importSpecifierNode: TImportSpecifier) => {\n            if (ImportDeclarationTransformer.isProhibitedImportSpecifierNode(importSpecifierNode)) {\n                return;\n            }\n\n            this.identifierObfuscatingReplacer.storeGlobalName(importSpecifierNode.local.name, lexicalScopeNode);\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] =\n            <ESTree.Identifier[]>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedPropertyNode (node: ESTree.Node): node is ESTree.Property & {key: ESTree.Identifier} {\n        return NodeGuards.isPropertyNode(node)\n            && node.shorthand\n            && NodeGuards.isIdentifierNode(node.key);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isFunctionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(functionNode);\n\n        if (!lexicalScopeNode) {\n            return functionNode;\n        }\n\n        this.storeFunctionParams(functionNode, lexicalScopeNode);\n        this.replaceFunctionParams(functionNode, lexicalScopeNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, lexicalScopeNode: TNodeWithLexicalScope): void {\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                estraverse.traverse(paramsNode, {\n                    enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                        if (FunctionTransformer.isProhibitedPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.left.name, lexicalScopeNode);\n\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.name, lexicalScopeNode);\n                        }\n                    }\n                });\n            });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private replaceFunctionParams (\n        functionNode: ESTree.Function,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        ignoredIdentifierNamesSet: Set <string> = new Set()\n    ): void {\n        const replaceVisitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                /**\n                 * Should to process nested functions in different traverse loop to avoid wrong code generation\n                 */\n                if (NodeGuards.isFunctionNode(node)) {\n                    this.replaceFunctionParams(node, lexicalScopeNode, new Set(ignoredIdentifierNamesSet));\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                /**\n                 * Should to ignore all identifiers that related to shorthand properties\n                 */\n                if (FunctionTransformer.isProhibitedPropertyNode(node)) {\n                    ignoredIdentifierNamesSet.add(node.key.name);\n                }\n\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => estraverse.replace(paramsNode, replaceVisitor));\n\n        estraverse.replace(functionNode.body, replaceVisitor);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isFunctionDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(parentNode);\n\n        if (!lexicalScopeNode) {\n            return functionDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isClassDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (classDeclarationNode: ESTree.ClassDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(classDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return classDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(classDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(classDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(catchClauseNode);\n\n        if (!lexicalScopeNode) {\n            return catchClauseNode;\n        }\n\n        this.storeCatchClauseParam(catchClauseNode, lexicalScopeNode);\n        this.replaceCatchClauseParam(catchClauseNode, lexicalScopeNode);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        if (NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithLexicalScope } from '../../../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, Map<string, string>>}\n     */\n    private readonly blockScopesMap: Map<TNodeWithLexicalScope, Map<string, string>> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, lexicalScopeNode: TNodeWithLexicalScope): ESTree.Identifier {\n        if (this.blockScopesMap.has(lexicalScopeNode)) {\n            const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n            if (namesMap.has(nodeValue)) {\n                nodeValue = <string>namesMap.get(nodeValue);\n            }\n        }\n\n        return NodeFactory.identifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeGlobalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeLocalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { ImportDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ImportDeclarationTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ImportDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ImportDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate();\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { NumberUtils } from '../../utils/NumberUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = NumberUtils.toHex(randomInteger);\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate();\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const identifierName: string = this.generate();\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>((context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => {\n            let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n            return (options: IOptions) => {\n                if (cachedIdentifierNamesGenerator) {\n                    return cachedIdentifierNamesGenerator;\n                }\n\n                let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n                switch (options.identifierNamesGenerator) {\n                    case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                        );\n\n                        break;\n\n                    case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                    default:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                        );\n                }\n\n                cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n                return identifierNamesGenerator;\n            };\n        });\n});\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var selfDefendingFunc = function () {\n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {\n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { NumberUtils } from '../../utils/NumberUtils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: NumberUtils.toHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\nimport { TStringArrayStorage } from '../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {TStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: TStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: TStringArrayStorage,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        var StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            var regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            var expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (var i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = format(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = format(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = format(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            var func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (var i = 0; i < 1000; i--) {\n                            var isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var document;\n            var domain;\n            var location;\n            var hostname;\n\n            for (var d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n\n            if (!(\"~\" > domain)) {\n                for (var d2 in that[document]) {\n                    if (d2.length == 8 && d2.charCodeAt(7) == 110 && d2.charCodeAt(0) == 108) {\n                        location = d2;\n                        \n                        break;\n                    }\n                }\n\n                for (var d3 in that[document][location]) {\n                    if (d3.length == 8 && d3.charCodeAt(7) == 101 && d3.charCodeAt(0) == 104) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            var documentDomain = that[document][domain];\n            var documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            var currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            var func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return format(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(this, function () {\n                var regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                var regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:_0x(?:[a-f0-9]){4,6}|(?:\\\\\\\\b|\\\\\\\\d)[a-z0-9]{1,4}(?:\\\\\\\\b|\\\\\\\\d)\\\\)', 'i');\n       \n                var result = {debugProtectionFunctionName}('init');\n                \n                if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                    result('0');\n                } else {\n                    {debugProtectionFunctionName}();\n                }\n            })();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    var c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/array/from\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode([\n            NodeFactory.variableDeclaratorNode(\n                NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                NodeFactory.objectExpressionNode(propertyNodes)\n            )\n        ]);\n\n        structure = NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode([\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(controllerIdentifierName),\n                    NodeFactory.callExpressionNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.literalNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            NodeFactory.identifierNode('split')\n                        ),\n                        [\n                            NodeFactory.literalNode('|')\n                        ]\n                    )\n                ),\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(indexIdentifierName),\n                    NodeFactory.literalNode(0)\n                )\n            ]),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        var getGlobal = function () {\n            var globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        var that = getGlobal();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        var that;\n        \n        try {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prepend(nodeWithStatements, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.append(nodeWithStatements, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = NodeGuards.isSwitchCaseNode(nodeWithStatements)\n                ? nodeWithStatements.consequent.length\n                : nodeWithStatements.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/reflect/has-metadata\");","module.exports = require(\"@babel/runtime/core-js/reflect/define-metadata\");","module.exports = require(\"@babel/runtime/core-js/object/get-own-property-names\");","module.exports = require(\"@babel/runtime/core-js/reflect/get-metadata\");","module.exports = require(\"@babel/runtime/core-js/object/get-own-property-descriptor\");","module.exports = require(\"@babel/runtime/core-js/object/define-property\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class VariableDeclaratorPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {VariableDeclarator} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        if (\n            !NodeGuards.isIdentifierNode(hostNode.id)\n            || this.isProhibitedObjectExpressionNode(objectExpressionNode, hostNode.id)\n        ) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(objectExpressionNode, hostNode.id);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @returns {VariableDeclarator}\n     */\n    private getHostVariableDeclaratorNode (objectExpressionNode: ESTree.ObjectExpression): ESTree.VariableDeclarator | never {\n        const { parentNode } = objectExpressionNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclaratorNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclarator` node for `ObjectExpression` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {VariableDeclarator} variableDeclaratorNode\n     * @returns {VariableDeclaration}\n     */\n    private getHostVariableDeclarationNode (variableDeclaratorNode: ESTree.VariableDeclarator): ESTree.VariableDeclaration | never {\n        const { parentNode } = variableDeclaratorNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclarationNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclaration` node for `VariableDeclarator` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Identifier} memberExpressionHostNode\n     * @returns {boolean}\n     */\n    private isProhibitedObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Identifier\n    ): boolean {\n        const hostVariableDeclarator: ESTree.VariableDeclarator = this.getHostVariableDeclaratorNode(objectExpressionNode);\n        const hostVariableDeclaration: ESTree.VariableDeclaration = this.getHostVariableDeclarationNode(hostVariableDeclarator);\n        const { declarations } = hostVariableDeclaration;\n        const indexOfDeclarator: number = declarations.indexOf(hostVariableDeclarator);\n        const isLastDeclarator: boolean = indexOfDeclarator === (declarations.length - 1);\n\n        // avoid unnecessary checks\n        if (isLastDeclarator) {\n            return false;\n        }\n\n        const declaratorsAfterCurrentDeclarator: ESTree.VariableDeclarator[] = declarations.slice(indexOfDeclarator);\n\n        let isProhibitedObjectExpressionNode: boolean = false;\n\n        // should mark node as prohibited if that node using inside other variable declarators\n        declaratorsAfterCurrentDeclarator.forEach((variableDeclarator: ESTree.VariableDeclarator) => {\n            estraverse.traverse(variableDeclarator, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | ESTree.Node => {\n                    if (\n                        NodeGuards.isMemberExpressionNode(node)\n                        && NodeGuards.isIdentifierNode(node.object)\n                        && node.object.name === memberExpressionHostNode.name\n                    ) {\n                        isProhibitedObjectExpressionNode = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n\n                    return node;\n                }\n            });\n        });\n\n        return isProhibitedObjectExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        let transformedNode: ESTree.Node;\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            transformedNode = root;\n        } else {\n            transformedNode = nodes[0];\n        }\n\n        NodeUtils.parentizeAst(transformedNode);\n\n        return transformedNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (!property.key) {\n                    return;\n                }\n\n                if (property.computed) {\n                    this.transformComputedProperty(property);\n                } else {\n                    this.transformBaseProperty(property);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformComputedProperty (property: ESTree.Property): void {\n        if (!NodeGuards.isLiteralNode(property.key) || !(typeof property.key.value === 'string')) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.value));\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformBaseProperty (property: ESTree.Property): void {\n        if (property.shorthand) {\n            property.shorthand = false;\n        }\n\n        if (!NodeGuards.isIdentifierNode(property.key)) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.name));\n    }\n\n    /**\n     * @param {string} inputValue\n     * @returns {string}\n     */\n    private getPropertyKeyValue (inputValue: string): string {\n        return this.options.unicodeEscapeSequence\n            ? this.escapeSequenceEncoder.encode(inputValue, true)\n            : inputValue;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TPropertiesExtractorFactory } from '../../types/container/node-transformers/TPropertiesExtractorFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { PropertiesExtractor } from '../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<string, PropertiesExtractor>}\n     */\n    private static readonly propertiesExtractorsMap: Map <string, PropertiesExtractor> = new Map([\n        [NodeType.AssignmentExpression, PropertiesExtractor.AssignmentExpressionPropertiesExtractor],\n        [NodeType.VariableDeclarator, PropertiesExtractor.VariableDeclaratorPropertiesExtractor]\n    ]);\n\n    /**\n     * @type {TPropertiesExtractorFactory}\n     */\n    private readonly propertiesExtractorFactory: TPropertiesExtractorFactory;\n\n    /**\n     * @param {TPropertiesExtractorFactory} propertiesExtractorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IPropertiesExtractor)\n            propertiesExtractorFactory: TPropertiesExtractorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.propertiesExtractorFactory = propertiesExtractorFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        if (transformationStage !== TransformationStage.Converting) {\n            return null;\n        }\n\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    this.options.transformObjectKeys\n                    && parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {MemberExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractorName: PropertiesExtractor | undefined = ObjectExpressionKeysTransformer\n            .propertiesExtractorsMap\n            .get(parentNode.type);\n\n        if (!propertiesExtractorName) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(propertiesExtractorName);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            NodeGuards.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(methodDefinitionNode.key.name);\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\n\n@injectable()\nexport class AssignmentExpressionPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {AssignmentExpression} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.AssignmentExpression\n    ): ESTree.Node {\n        const leftNode: ESTree.MemberExpression | ESTree.Pattern = hostNode.left;\n\n        // left node shouldn't be as Pattern node\n        if (AbstractPropertiesExtractor.isProhibitedPattern(leftNode)) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            leftNode\n        );\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { PropertiesExtractor } from '../../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\n\nimport { AssignmentExpressionPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclaratorPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n\n    // properties extractors\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(AssignmentExpressionPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.AssignmentExpressionPropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(VariableDeclaratorPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.VariableDeclaratorPropertiesExtractor);\n\n    // properties extractor factory\n    bind<IPropertiesExtractor>(ServiceIdentifiers.Factory__IPropertiesExtractor)\n        .toFactory<IPropertiesExtractor>(InversifyContainerFacade\n            .getCacheFactory<PropertiesExtractor, IPropertiesExtractor>(\n                ServiceIdentifiers.IPropertiesExtractor\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralNode\n        );\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.LogicalExpressionFunctionNode\n        );\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithStatements>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithStatements> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithStatements = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ControlFlowStorageNode\n        );\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prepend(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithStatements} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithStatements): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                if (NodeGuards.isSwitchCaseNode(hostNode)) {\n                    hostNode.consequent.shift();\n                } else {\n                    hostNode.body.shift();\n                }\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithStatements}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithStatements {\n        const blockScopesOfNode: TNodeWithStatements[] = NodeStatementUtils.getParentNodesWithStatements(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TDeadNodeInjectionCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const parentNodeWithStatements: TNodeWithStatements = NodeStatementUtils\n            .getParentNodeWithStatements(blockStatementNode);\n\n        return parentNodeWithStatements.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                const clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                const transformedBlockStatementNode: ESTree.BlockStatement =\n                    this.makeClonedBlockStatementNodeUnique(clonedBlockStatementNode);\n\n                this.collectedBlockStatements.push(transformedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * Make all identifiers in cloned block statement unique\n     *\n     * @param {BlockStatement} clonedBlockStatementNode\n     * @returns {BlockStatement}\n     */\n    private makeClonedBlockStatementNodeUnique (clonedBlockStatementNode: ESTree.BlockStatement): ESTree.BlockStatement {\n        // should wrap cloned block statement node into function node for correct scope encapsulation\n        const hostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], clonedBlockStatementNode);\n\n        NodeUtils.parentizeNode(hostNode, hostNode);\n        NodeUtils.parentizeNode(clonedBlockStatementNode, hostNode);\n\n        return this.transformersRunner.transform(\n            hostNode,\n            DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n            TransformationStage.Obfuscating\n        ).body;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode = this.deadCodeInjectionCustomNodeFactory(\n            DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode\n        );\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionFunctionNode\n        );\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(node)\n            || NodeGuards.isContinueStatementNode(node);\n        const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(node)\n            && (node.kind === 'const' || node.kind === 'let');\n        const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(node);\n\n        return NodeGuards.isFunctionDeclarationNode(node)\n            || isBreakOrContinueStatement\n            || isVariableDeclarationWithLetOrConstKind\n            || isClassDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (BlockStatementControlFlowTransformer.isProhibitedStatementNode(node)) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.createWithRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.shuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BinaryExpressionFunctionNode\n        );\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/stack-trace-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n/**\n * This class generates a data with a stack trace of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (astTree: ESTree.Program): IStackTraceData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeStatementUtils.getParentNodeWithStatements(node)) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../analyzers/stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // callee data extractor factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","module.exports = require(\"@babel/runtime/helpers/construct\");","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscatorFacade';\n\nmodule.exports = JavaScriptObfuscator;\n"],"sourceRoot":""}